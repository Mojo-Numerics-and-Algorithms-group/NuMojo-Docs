{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NuMojo","text":"<p>Numojo is an numerics library for Mojo similiar to numpy for Python.</p>"},{"location":"#this-site-is-a-work-in-progress","title":"This site is a work in progress.","text":""},{"location":"docs/core/array_creation_routines/","title":"array_creation_routines","text":""},{"location":"docs/core/array_creation_routines/#module-summary","title":"Module Summary","text":"<p>Array creation routine.</p>"},{"location":"docs/core/array_creation_routines/#arange","title":"arange","text":"<p><pre><code>arange[in_dtype: DType, out_dtype: DType = float64](start: SIMD[in_dtype, 1], stop: SIMD[in_dtype, 1], step: SIMD[in_dtype, 1] = 1) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Function that computes a series of values starting from \"start\" to \"stop\" with given \"step\" size.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: Input datatype of the input values.</li> <li>out_dtype: Output datatype of the output NDArray. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>start: Scalar[in_dtype] - Start value.</li> <li>stop: Scalar[in_dtype]  - End value.</li> <li>step: Scalar[in_dtype]  - Step size between each element (default 1). Default: 1</li> </ul>"},{"location":"docs/core/array_creation_routines/#linspace","title":"linspace","text":"<p><pre><code>linspace[in_dtype: DType, out_dtype: DType = float64](start: SIMD[in_dtype, 1], stop: SIMD[in_dtype, 1], num: Int = 50, endpoint: Bool = 1, parallel: Bool = 0) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Function that computes a series of linearly spaced values starting from \"start\" to \"stop\" with given size. Wrapper function for _linspace_serial, _linspace_parallel.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: Datatype of the input values.</li> <li>out_dtype: Datatype of the output NDArray. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>start: Start value.</li> <li>stop: End value.</li> <li>num: No of linearly spaced elements. Default: 50</li> <li>endpoint: Specifies whether to include endpoint in the final NDArray, defaults to True. Default: 1</li> <li>parallel: Specifies whether the linspace should be calculated using parallelization, deafults to False. Default: 0</li> </ul>"},{"location":"docs/core/array_creation_routines/#logspace","title":"logspace","text":"<p><pre><code>logspace[in_dtype: DType, out_dtype: DType = float64](start: SIMD[in_dtype, 1], stop: SIMD[in_dtype, 1], num: Int, endpoint: Bool = 1, base: SIMD[in_dtype, 1] = #kgen.float_literal&lt;10|1&gt;, parallel: Bool = 0) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Generate a logrithmic spaced NDArray of <code>num</code> elements between <code>start</code> and <code>stop</code>. Wrapper function for _logspace_serial, _logspace_parallel functions.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: Datatype of the input values.</li> <li>out_dtype: Datatype of the output NDArray. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>start: The starting value of the NDArray.</li> <li>stop: The ending value of the NDArray.</li> <li>num: The number of elements in the NDArray.</li> <li>endpoint: Whether to include the <code>stop</code> value in the NDArray. Defaults to True. Default: 1</li> <li>base: Base value of the logarithm, defaults to 10. Default: #kgen.float_literal&lt;10|1&gt;</li> <li>parallel: Specifies whether to calculate the logarithmic spaced values using parallelization. Default: 0</li> </ul>"},{"location":"docs/core/array_creation_routines/#geomspace","title":"geomspace","text":"<p><pre><code>geomspace[in_dtype: DType, out_dtype: DType = float64](start: SIMD[in_dtype, 1], stop: SIMD[in_dtype, 1], num: Int, endpoint: Bool = 1) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Generate a NDArray of <code>num</code> elements between <code>start</code> and <code>stop</code> in a geometric series.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: Datatype of the input values.</li> <li>out_dtype: Datatype of the output NDArray. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>start: The starting value of the NDArray.</li> <li>stop: The ending value of the NDArray.</li> <li>num: The number of elements in the NDArray.</li> <li>endpoint: Whether to include the <code>stop</code> value in the NDArray. Defaults to True. Default: 1</li> </ul>"},{"location":"docs/core/array_creation_routines/#empty","title":"empty","text":"<p><pre><code>empty[dtype: DType](*shape: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Generate a NDArray of given shape with arbitrary values.  </p> <p>Parameters:  </p> <ul> <li>dtype: Datatype of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>*shape: Shape of the NDArray.</li> </ul>"},{"location":"docs/core/array_creation_routines/#zeros","title":"zeros","text":"<p><pre><code>zeros[dtype: DType](*shape: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Generate a NDArray of zeros with given shape.  </p> <p>Parameters:  </p> <ul> <li>dtype: Datatype of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>*shape: Shape of the NDArray.</li> </ul>"},{"location":"docs/core/array_creation_routines/#eye","title":"eye","text":"<p><pre><code>eye[dtype: DType](N: Int, M: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Return a 2-D NDArray with ones on the diagonal and zeros elsewhere.  </p> <p>Parameters:  </p> <ul> <li>dtype: Datatype of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>N: Number of rows in the matrix.</li> <li>M: Number of columns in the matrix.</li> </ul>"},{"location":"docs/core/array_creation_routines/#identity","title":"identity","text":"<p><pre><code>identity[dtype: DType](N: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Generate an identity matrix of size N x N.  </p> <p>Parameters:  </p> <ul> <li>dtype: Datatype of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>N: Size of the matrix.</li> </ul>"},{"location":"docs/core/array_creation_routines/#ones","title":"ones","text":"<p><pre><code>ones[dtype: DType](*shape: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Generate a NDArray of ones with given shape filled with ones.  </p> <p>Parameters:  </p> <ul> <li>dtype: Datatype of the NDArray.</li> </ul> <p>Args:  </p> <ul> <li>*shape: Shape of the NDArray.</li> </ul>"},{"location":"docs/core/array_creation_routines/#full","title":"full","text":"<p><pre><code>full[dtype: DType](*shape: Int, *, fill_value: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Generate a NDArray of <code>fill_value</code> with given shape.  </p> <p>Parameters:  </p> <ul> <li>dtype: Datatype of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>*shape: Shape of the NDArray.</li> <li>fill_value: Value to be splatted over the NDArray.</li> </ul> <p><pre><code>full[dtype: DType](shape: VariadicList[Int], fill_value: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Generate a NDArray of <code>fill_value</code> with given shape.  </p> <p>Parameters:  </p> <ul> <li>dtype: Datatype of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>shape: Shape of the NDArray.</li> <li>fill_value: Value to be splatted over the NDArray.</li> </ul>"},{"location":"docs/core/array_creation_routines/#diagflat","title":"diagflat","text":"<p><pre><code>diagflat()\n</code></pre> Summary  </p>"},{"location":"docs/core/array_creation_routines/#tri","title":"tri","text":"<p><pre><code>tri()\n</code></pre> Summary  </p>"},{"location":"docs/core/array_creation_routines/#tril","title":"tril","text":"<p><pre><code>tril()\n</code></pre> Summary  </p>"},{"location":"docs/core/array_creation_routines/#triu","title":"triu","text":"<p><pre><code>triu()\n</code></pre> Summary  </p>"},{"location":"docs/core/array_manipulation_routines/","title":"array_manipulation_routines","text":""},{"location":"docs/core/array_manipulation_routines/#module-summary","title":"Module Summary","text":"<p>Array manipulation routines.</p>"},{"location":"docs/core/array_manipulation_routines/#copyto","title":"copyto","text":"<p><pre><code>copyto()\n</code></pre> Summary  </p>"},{"location":"docs/core/array_manipulation_routines/#shape","title":"shape","text":"<p><pre><code>shape()\n</code></pre> Summary  </p>"},{"location":"docs/core/array_manipulation_routines/#reshape","title":"reshape","text":"<p><pre><code>reshape()\n</code></pre> Summary  </p>"},{"location":"docs/core/array_manipulation_routines/#ravel","title":"ravel","text":"<p><pre><code>ravel()\n</code></pre> Summary  </p>"},{"location":"docs/core/constants/","title":"constants","text":""},{"location":"docs/core/constants/#module-summary","title":"Module Summary","text":"<p>Constants</p>"},{"location":"docs/core/constants/#constants_1","title":"Constants","text":""},{"location":"docs/core/constants/#constants-summary","title":"Constants Summary","text":"<p>Define constants.  </p>"},{"location":"docs/core/constants/#parent-traits","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Copyable</li> <li>Movable</li> </ul>"},{"location":"docs/core/constants/#aliases","title":"Aliases","text":"<p><code>c</code>:  <code>pi</code>:  <code>e</code>:   </p>"},{"location":"docs/core/constants/#functions","title":"Functions","text":""},{"location":"docs/core/constants/#init","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Initializes the constants.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/constants/#del","title":"del","text":"<p><pre><code>__del__(owned self: Self)\n</code></pre> Summary  </p> <p>Deletes the constants.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/datatypes/","title":"datatypes","text":""},{"location":"docs/core/datatypes/#module-summary","title":"Module Summary","text":"<p>Datatypes Module - Implements datatypes aliases, conversions</p>"},{"location":"docs/core/datatypes/#aliases","title":"Aliases","text":"<p><code>i8</code>: Data type alias for DType.int8 <code>i16</code>: Data type alias for DType.int16 <code>i32</code>: Data type alias for DType.int32 <code>i64</code>: Data type alias for DType.int64 <code>u8</code>: Data type alias for DType.uint8 <code>u16</code>: Data type alias for DType.uint16 <code>u32</code>: Data type alias for DType.uint32 <code>u64</code>: Data type alias for DType.uint64 <code>f16</code>: Data type alias for DType.float16 <code>f32</code>: Data type alias for DType.float32 <code>f64</code>: Data type alias for DType.float64</p>"},{"location":"docs/core/datatypes/#cvtdtype","title":"cvtdtype","text":"<p><pre><code>cvtdtype[in_dtype: DType, out_dtype: DType, width: Int = 1](value: SIMD[in_dtype, width]) -&gt; SIMD[$1, $2]\n</code></pre> Summary  </p> <p>Converts datatype of a value from in_dtype to out_dtype at run time.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input datatype.</li> <li>out_dtype: The output dataytpe.</li> <li>width: The width of the SIMD vector. Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>value: The SIMD value to be converted.</li> </ul> <p><pre><code>cvtdtype[in_dtype: DType, out_dtype: DType, width: Int = 1, value: SIMD[$0, $2] = __init__[stdlib::builtin::bool::Boolable](SIMD())]() -&gt; SIMD[$1, $2]\n</code></pre> Summary  </p> <p>Converts datatype of a value from in_dtype to out_dtype at compile time.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input datatype.</li> <li>out_dtype: The output dataytpe.</li> <li>width: The width of the SIMD vector. Defualt: <code>1</code></li> <li>value: The SIMD value to be converted. Defualt: <code>__init__[stdlib::builtin::bool::Boolable](SIMD())</code></li> </ul>"},{"location":"docs/core/ndarray/","title":"ndarray","text":""},{"location":"docs/core/ndarray/#module-summary","title":"Module Summary","text":"<p>Implements N-Dimensional Array</p>"},{"location":"docs/core/ndarray/#ndarrayshape","title":"NDArrayShape","text":""},{"location":"docs/core/ndarray/#ndarrayshape-summary","title":"NDArrayShape Summary","text":"<p>Implements the NDArrayShape.  </p>"},{"location":"docs/core/ndarray/#parent-traits","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Stringable</li> </ul>"},{"location":"docs/core/ndarray/#fields","title":"Fields","text":"<ul> <li>ndsize <code>Int</code> <ul> <li>Total no of elements in the corresponding array.  </li> </ul> </li> <li>ndshape <code>DTypePointer[dtype, 0]</code> <ul> <li>Shape of the corresponding array.  </li> </ul> </li> <li>ndlen <code>Int</code> <ul> <li>Length of ndshape.  </li> </ul> </li> </ul>"},{"location":"docs/core/ndarray/#functions","title":"Functions","text":""},{"location":"docs/core/ndarray/#init","title":"init","text":"<p><pre><code>__init__(inout self: Self, *shape: Int)\n</code></pre> Summary  </p> <p>Initializes the NDArrayShape with variable shape dimensions.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*shape: Variable number of integers representing the shape dimensions.</li> </ul> <p><pre><code>__init__(inout self: Self, *shape: Int, *, size: Int)\n</code></pre> Summary  </p> <p>Initializes the NDArrayShape with variable shape dimensions and a specified size.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*shape: Variable number of integers representing the shape dimensions.</li> <li>size: The total number of elements in the array.</li> </ul> <p><pre><code>__init__(inout self: Self, shape: List[Int])\n</code></pre> Summary  </p> <p>Initializes the NDArrayShape with a list of shape dimensions.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: A list of integers representing the shape dimensions.</li> </ul> <p><pre><code>__init__(inout self: Self, shape: List[Int], size: Int)\n</code></pre> Summary  </p> <p>Initializes the NDArrayShape with a list of shape dimensions and a specified size.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: A list of integers representing the shape dimensions.</li> <li>size: The specified size of the NDArrayShape.</li> </ul> <p><pre><code>__init__(inout self: Self, shape: VariadicList[Int])\n</code></pre> Summary  </p> <p>Initializes the NDArrayShape with a list of shape dimensions.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: A list of integers representing the shape dimensions.</li> </ul> <p><pre><code>__init__(inout self: Self, shape: VariadicList[Int], size: Int)\n</code></pre> Summary  </p> <p>Initializes the NDArrayShape with a list of shape dimensions and a specified size.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: A list of integers representing the shape dimensions.</li> <li>size: The specified size of the NDArrayShape.</li> </ul> <p><pre><code>__init__(inout self: Self, shape: NDArrayShape[dtype])\n</code></pre> Summary  </p> <p>Initializes the NDArrayShape with another NDArrayShape.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: Another NDArrayShape to initialize from.</li> </ul>"},{"location":"docs/core/ndarray/#getitem","title":"getitem","text":"<p><pre><code>__getitem__(self: Self, index: Int) -&gt; Int\n</code></pre> Summary  </p> <p>Get shape at specified index.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul>"},{"location":"docs/core/ndarray/#setitem","title":"setitem","text":"<p><pre><code>__setitem__(inout self: Self, index: Int, val: Int)\n</code></pre> Summary  </p> <p>Set shape at specified index.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#eq","title":"eq","text":"<p><pre><code>__eq__(self: Self, other: Self) -&gt; Bool\n</code></pre> Summary  </p> <p>Check if two arrayshapes have identical dimensions.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#ne","title":"ne","text":"<p><pre><code>__ne__(self: Self, other: Self) -&gt; Bool\n</code></pre> Summary  </p> <p>Check if two arrayshapes don't have identical dimensions.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#contains","title":"contains","text":"<p><pre><code>__contains__(self: Self, val: Int) -&gt; Bool\n</code></pre> Summary  </p> <p>Check if any of the dimensions are equal to a value.  </p> <p>Args:  </p> <ul> <li>self</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#size","title":"size","text":"<p><pre><code>size(self: Self) -&gt; Int\n</code></pre> Summary  </p> <p>Get Size of array described by arrayshape.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#len","title":"len","text":"<p><pre><code>len(self: Self) -&gt; Int\n</code></pre> Summary  </p> <p>Get number of dimensions of the array described by arrayshape.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#load","title":"load","text":"<p><pre><code>load[width: Int = 1](self: Self, index: Int) -&gt; SIMD[dtype, $0]\n</code></pre> Summary  </p> <p>SIMD load dimensional information.  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul>"},{"location":"docs/core/ndarray/#store","title":"store","text":"<p><pre><code>store[width: Int = 1](inout self: Self, index: Int, val: SIMD[dtype, width])\n</code></pre> Summary  </p> <p>SIMD store dimensional information.  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#load_int","title":"load_int","text":"<p><pre><code>load_int(self: Self, index: Int) -&gt; Int\n</code></pre> Summary  </p> <p>SIMD load dimensional information.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul>"},{"location":"docs/core/ndarray/#store_int","title":"store_int","text":"<p><pre><code>store_int(inout self: Self, index: Int, val: Int)\n</code></pre> Summary  </p> <p>SIMD store dimensional information.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#ndarraystride","title":"NDArrayStride","text":""},{"location":"docs/core/ndarray/#ndarraystride-summary","title":"NDArrayStride Summary","text":"<p>Implements the NDArrayStride.  </p>"},{"location":"docs/core/ndarray/#parent-traits_1","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Stringable</li> </ul>"},{"location":"docs/core/ndarray/#fields_1","title":"Fields","text":"<ul> <li>ndoffset <code>Int</code> </li> <li>ndstride <code>DTypePointer[dtype, 0]</code> </li> <li>ndlen <code>Int</code> </li> </ul>"},{"location":"docs/core/ndarray/#functions_1","title":"Functions","text":""},{"location":"docs/core/ndarray/#init_1","title":"init","text":"<p><pre><code>__init__(inout self: Self, *stride: Int, *, offset: Int = 0)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>*stride</li> <li>offset Default: 0</li> </ul> <p><pre><code>__init__(inout self: Self, stride: List[Int], offset: Int = 0)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>stride</li> <li>offset Default: 0</li> </ul> <p><pre><code>__init__(inout self: Self, stride: VariadicList[Int], offset: Int = 0)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>stride</li> <li>offset Default: 0</li> </ul> <p><pre><code>__init__(inout self: Self, stride: NDArrayStride[dtype])\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>stride</li> </ul> <p><pre><code>__init__(inout self: Self, stride: NDArrayStride[dtype], offset: Int = 0)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>stride</li> <li>offset Default: 0</li> </ul> <p><pre><code>__init__(inout self: Self, *shape: Int, *, offset: Int = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>*shape</li> <li>offset Default: 0</li> <li>order Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: List[Int], offset: Int = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape</li> <li>offset Default: 0</li> <li>order Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: VariadicList[Int], offset: Int = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape</li> <li>offset Default: 0</li> <li>order Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, owned shape: NDArrayShape[dtype], offset: Int = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape</li> <li>offset Default: 0</li> <li>order Default: \"C\"</li> </ul>"},{"location":"docs/core/ndarray/#getitem_1","title":"getitem","text":"<p><pre><code>__getitem__(self: Self, index: Int) -&gt; Int\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul>"},{"location":"docs/core/ndarray/#setitem_1","title":"setitem","text":"<p><pre><code>__setitem__(inout self: Self, index: Int, val: Int)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#eq_1","title":"eq","text":"<p><pre><code>__eq__(self: Self, other: Self) -&gt; Bool\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#ne_1","title":"ne","text":"<p><pre><code>__ne__(self: Self, other: Self) -&gt; Bool\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#contains_1","title":"contains","text":"<p><pre><code>__contains__(self: Self, val: Int) -&gt; Bool\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#len_1","title":"len","text":"<p><pre><code>len(self: Self) -&gt; Int\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#load_1","title":"load","text":"<p><pre><code>load[width: Int = 1](self: Self, index: Int) -&gt; SIMD[dtype, $0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul>"},{"location":"docs/core/ndarray/#store_1","title":"store","text":"<p><pre><code>store[width: Int = 1](inout self: Self, index: Int, val: SIMD[dtype, width])\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#load_unsafe","title":"load_unsafe","text":"<p><pre><code>load_unsafe[width: Int = 1](self: Self, index: Int) -&gt; Int\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul>"},{"location":"docs/core/ndarray/#store_unsafe","title":"store_unsafe","text":"<p><pre><code>store_unsafe[width: Int = 1](inout self: Self, index: Int, val: SIMD[dtype, width])\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#ndarray_1","title":"NDArray","text":""},{"location":"docs/core/ndarray/#ndarray-summary","title":"NDArray Summary","text":"<p>The N-dimensional array (NDArray).  </p>"},{"location":"docs/core/ndarray/#parent-traits_2","title":"Parent Traits","text":"<ul> <li>Absable</li> <li>AnyType</li> <li>CollectionElement</li> <li>Copyable</li> <li>Movable</li> <li>Representable</li> <li>Sized</li> <li>Stringable</li> </ul>"},{"location":"docs/core/ndarray/#aliases","title":"Aliases","text":"<p><code>simd_width</code>: Vector size of the data type.</p>"},{"location":"docs/core/ndarray/#fields_2","title":"Fields","text":"<ul> <li>data <code>DTypePointer[dtype, 0]</code> <ul> <li>Data buffer of the items in the NDArray.  </li> </ul> </li> <li>ndim <code>Int</code> <ul> <li>Number of Dimensions.  </li> </ul> </li> <li>ndshape <code>NDArrayShape[int32]</code> <ul> <li>Size and shape of NDArray.  </li> </ul> </li> <li>stride <code>NDArrayStride[int32]</code> <ul> <li>Contains offset, strides.  </li> </ul> </li> <li>coefficient <code>NDArrayStride[int32]</code> <ul> <li>Contains offset, coefficient.  </li> </ul> </li> <li>datatype <code>DType</code> <ul> <li>The datatype of memory.  </li> </ul> </li> <li>order <code>String</code> <ul> <li>Memory layout of array C (C order row major) or F (Fortran order col major).  </li> </ul> </li> </ul>"},{"location":"docs/core/ndarray/#functions_2","title":"Functions","text":""},{"location":"docs/core/ndarray/#init_2","title":"init","text":"<p><pre><code>__init__(inout self: Self, *shape: Int, *, random: Bool = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for variadic shape.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*shape: Variadic shape.</li> <li>random: Set the values randomly. Default: 0</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: List[Int], random: Bool = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for list shape.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: List of shape.</li> <li>random: Set the values randomly. Default: 0</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: VariadicList[Int], random: Bool = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for variadic shape.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: Variadic List shape.</li> <li>random: Set the values randomly. Default: 0</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, *shape: Int, *, fill: SIMD[dtype, 1], order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for variadic shape with option to fill.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*shape: Variadic shape.</li> <li>fill: Set all the values to this.</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: List[Int], fill: SIMD[dtype, 1], order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for variadic shape with option to fill.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: List of shape.</li> <li>fill: Set all the values to this.</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: VariadicList[Int], fill: SIMD[dtype, 1], order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for List of shape with option to fill.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: Variadic List of shape.</li> <li>fill: Set all the values to this.</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: NDArrayShape[dtype], random: Bool = 0, order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for NDArrayShape.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: Variadic shape.</li> <li>random: Set all the values randomly. Default: 0</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, shape: NDArrayShape[dtype], fill: SIMD[dtype, 1], order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization for NDArrayShape with option to fill.  </p> <p>Args:  </p> <ul> <li>self</li> <li>shape: Variadic shape.</li> <li>fill: Set all the the values to this.</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, data: List[SIMD[dtype, 1]], shape: List[Int], order: String = \"C\")\n</code></pre> Summary  </p> <p>NDArray initialization from list of data.  </p> <p>Args:  </p> <ul> <li>self</li> <li>data: List of data.</li> <li>shape: List of shape.</li> <li>order: Memory order C or F. Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, ndim: Int, offset: Int, size: Int, shape: List[Int], strides: List[Int], coefficient: List[Int], order: String = \"C\")\n</code></pre> Summary  </p> <p>Extremely specific NDArray initializer.  </p> <p>Args:  </p> <ul> <li>self</li> <li>ndim</li> <li>offset</li> <li>size</li> <li>shape</li> <li>strides</li> <li>coefficient</li> <li>order Default: \"C\"</li> </ul> <p><pre><code>__init__(inout self: Self, data: DTypePointer[dtype, 0], ndim: Int, offset: Int, shape: List[Int], strides: List[Int], coefficient: List[Int], order: String = \"C\")\n</code></pre> Summary  </p> <p>Extremely specific NDArray initializer.  </p> <p>Args:  </p> <ul> <li>self</li> <li>data</li> <li>ndim</li> <li>offset</li> <li>shape</li> <li>strides</li> <li>coefficient</li> <li>order Default: \"C\"</li> </ul>"},{"location":"docs/core/ndarray/#copyinit","title":"copyinit","text":"<p><pre><code>__copyinit__(inout self: Self, other: Self)\n</code></pre> Summary  </p> <p>Copy other into self.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#moveinit","title":"moveinit","text":"<p><pre><code>__moveinit__(inout self: Self, owned existing: Self)\n</code></pre> Summary  </p> <p>Move other into self.  </p> <p>Args:  </p> <ul> <li>self</li> <li>existing</li> </ul>"},{"location":"docs/core/ndarray/#del","title":"del","text":"<p><pre><code>__del__(owned self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#bool","title":"bool","text":"<p><pre><code>__bool__(self: Self) -&gt; Bool\n</code></pre> Summary  </p> <p>If all true return true.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#getitem_2","title":"getitem","text":"<p><pre><code>__getitem__(self: Self, idx: Int) -&gt; Self\n</code></pre> Summary  </p> <p>Retreive a slice of the array corrisponding to the index at the first dimension.  </p> <p>Args:  </p> <ul> <li>self</li> <li>idx</li> </ul> <p><pre><code>__getitem__(self: Self, owned *slices: Slice) -&gt; Self\n</code></pre> Summary  </p> <p>Retreive slices of an array from variadic slices.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*slices</li> </ul> <p><pre><code>__getitem__(self: Self, owned slices: List[Slice]) -&gt; Self\n</code></pre> Summary  </p> <p>Retreive slices of an array from list of slices.  </p> <p>Args:  </p> <ul> <li>self</li> <li>slices</li> </ul> <p><pre><code>__getitem__(self: Self, owned *slices: Variant[Slice, Int]) -&gt; Self\n</code></pre> Summary  </p> <p>Get items by a series of either slices or integers.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*slices: A series of either Slice or Int.</li> </ul> <p><pre><code>__getitem__(self: Self, index: List[Int]) -&gt; Self\n</code></pre> Summary  </p> <p>Get items of array from a list of indices.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index: List[Int].</li> </ul> <p><pre><code>__getitem__(self: Self, index: NDArray[index]) -&gt; Self\n</code></pre> Summary  </p> <p>Get items of array from an array of indices.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul> <p><pre><code>__getitem__(self: Self, mask: NDArray[bool]) -&gt; Self\n</code></pre> Summary  </p> <p>Get items of array corrisponding to a mask.  </p> <p>Args:  </p> <ul> <li>self</li> <li>mask: NDArray with Dtype.bool.</li> </ul>"},{"location":"docs/core/ndarray/#setitem_2","title":"setitem","text":"<p><pre><code>__setitem__(inout self: Self, index: Int, val: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Set the value of a single index.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul> <p><pre><code>__setitem__(inout self: Self, *index: Int, *, val: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Set the value at the index list.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*index</li> <li>val</li> </ul> <p><pre><code>__setitem__(inout self: Self, index: List[Int], val: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Set the value at the index list.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul> <p><pre><code>__setitem__(inout self: Self, index: VariadicList[Int], val: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Set the value at the index corisponding to the varaidic list.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul> <p><pre><code>__setitem__(inout self: Self, mask: NDArray[bool], value: Self)\n</code></pre> Summary  </p> <p>Set the value of the array at the indices where the mask is true.  </p> <p>Args:  </p> <ul> <li>self</li> <li>mask</li> <li>value</li> </ul>"},{"location":"docs/core/ndarray/#neg","title":"neg","text":"<p><pre><code>__neg__(self: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Unary negative returens self unless boolean type.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#pos","title":"pos","text":"<p><pre><code>__pos__(self: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Unary positve returens self unless boolean type.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#invert","title":"invert","text":"<p><pre><code>__invert__(self: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Elementwise inverse (~ or not), only for bools and integral types.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#lt","title":"lt","text":"<p><pre><code>__lt__(self: Self, other: SIMD[dtype, 1]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise less than.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__lt__(self: Self, other: Self) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise less than between scalar and Array.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#le","title":"le","text":"<p><pre><code>__le__(self: Self, other: SIMD[dtype, 1]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise less than or equal to.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__le__(self: Self, other: Self) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise less than or equal to between scalar and Array.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#eq_2","title":"eq","text":"<p><pre><code>__eq__(self: Self, other: Self) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise equivelence.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__eq__(self: Self, other: SIMD[dtype, 1]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise equivelence between scalar and Array.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#ne_2","title":"ne","text":"<p><pre><code>__ne__(self: Self, other: SIMD[dtype, 1]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise nonequivelence.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__ne__(self: Self, other: Self) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise nonequivelence between scalar and Array.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#gt","title":"gt","text":"<p><pre><code>__gt__(self: Self, other: SIMD[dtype, 1]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise greater than.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__gt__(self: Self, other: Self) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise greater than between scalar and Array.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#ge","title":"ge","text":"<p><pre><code>__ge__(self: Self, other: SIMD[dtype, 1]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise greater than or equal to.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__ge__(self: Self, other: Self) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Itemwise less than or equal to between scalar and Array.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#add","title":"add","text":"<p><pre><code>__add__(inout self: Self, other: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array + scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__add__(inout self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array + array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#sub","title":"sub","text":"<p><pre><code>__sub__(self: Self, other: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array - scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__sub__(self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array - array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#mul","title":"mul","text":"<p><pre><code>__mul__(self: Self, other: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array * scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__mul__(self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array * array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#matmul","title":"matmul","text":"<p><pre><code>__matmul__(self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#truediv","title":"truediv","text":"<p><pre><code>__truediv__(self: Self, other: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array / scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__truediv__(self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array / array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#floordiv","title":"floordiv","text":"<p><pre><code>__floordiv__(self: Self, other: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array // scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__floordiv__(self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array // array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#mod","title":"mod","text":"<p><pre><code>__mod__(inout self: Self, other: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array % scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__mod__(inout self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>array % array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#pow","title":"pow","text":"<p><pre><code>__pow__(self: Self, p: Int) -&gt; Self\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>p</li> </ul> <p><pre><code>__pow__(self: Self, p: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>p</li> </ul>"},{"location":"docs/core/ndarray/#radd","title":"radd","text":"<p><pre><code>__radd__(inout self: Self, rhs: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>scalar + array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>rhs</li> </ul>"},{"location":"docs/core/ndarray/#rsub","title":"rsub","text":"<p><pre><code>__rsub__(self: Self, s: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>scalar - array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul>"},{"location":"docs/core/ndarray/#rmul","title":"rmul","text":"<p><pre><code>__rmul__(self: Self, s: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>scalar * array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul>"},{"location":"docs/core/ndarray/#rtruediv","title":"rtruediv","text":"<p><pre><code>__rtruediv__(self: Self, s: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>scalar / array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul>"},{"location":"docs/core/ndarray/#rfloordiv","title":"rfloordiv","text":"<p><pre><code>__rfloordiv__(self: Self, s: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>scalar // array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul>"},{"location":"docs/core/ndarray/#rmod","title":"rmod","text":"<p><pre><code>__rmod__(inout self: Self, other: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Enables <code>scalar % array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#iadd","title":"iadd","text":"<p><pre><code>__iadd__(inout self: Self, other: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Enables <code>array += scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__iadd__(inout self: Self, other: Self)\n</code></pre> Summary  </p> <p>Enables <code>array *= array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#isub","title":"isub","text":"<p><pre><code>__isub__(inout self: Self, s: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Enables <code>array -= scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul> <p><pre><code>__isub__(inout self: Self, s: Self)\n</code></pre> Summary  </p> <p>Enables <code>array -= array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul>"},{"location":"docs/core/ndarray/#imul","title":"imul","text":"<p><pre><code>__imul__(inout self: Self, s: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Enables <code>array *= scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul> <p><pre><code>__imul__(inout self: Self, s: Self)\n</code></pre> Summary  </p> <p>Enables <code>array *= array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul>"},{"location":"docs/core/ndarray/#itruediv","title":"itruediv","text":"<p><pre><code>__itruediv__(inout self: Self, s: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Enables <code>array /= scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul> <p><pre><code>__itruediv__(inout self: Self, other: Self)\n</code></pre> Summary  </p> <p>Enables <code>array /= array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#ifloordiv","title":"ifloordiv","text":"<p><pre><code>__ifloordiv__(inout self: Self, s: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Enables <code>array //= scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>s</li> </ul> <p><pre><code>__ifloordiv__(inout self: Self, other: Self)\n</code></pre> Summary  </p> <p>Enables <code>array //= array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#imod","title":"imod","text":"<p><pre><code>__imod__(inout self: Self, other: SIMD[dtype, 1])\n</code></pre> Summary  </p> <p>Enables <code>array %= scalar</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul> <p><pre><code>__imod__(inout self: Self, other: Self)\n</code></pre> Summary  </p> <p>Enables <code>array %= array</code>.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#ipow","title":"ipow","text":"<p><pre><code>__ipow__(inout self: Self, p: Int)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> <li>p</li> </ul>"},{"location":"docs/core/ndarray/#get_scalar","title":"get_scalar","text":"<p><pre><code>get_scalar(self: Self, index: Int) -&gt; SIMD[dtype, 1]\n</code></pre> Summary  </p> <p>Linearly retreive a value from the underlying Pointer.  </p> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul>"},{"location":"docs/core/ndarray/#vdot","title":"vdot","text":"<p><pre><code>vdot(self: Self, other: Self) -&gt; SIMD[dtype, 1]\n</code></pre> Summary  </p> <p>Inner product of two vectors.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#mdot","title":"mdot","text":"<p><pre><code>mdot(self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Dot product of two matrix. Matrix A: M * N. Matrix B: N * L.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#row","title":"row","text":"<p><pre><code>row(self: Self, id: Int) -&gt; Self\n</code></pre> Summary  </p> <p>Get the ith row of the matrix.  </p> <p>Args:  </p> <ul> <li>self</li> <li>id</li> </ul>"},{"location":"docs/core/ndarray/#col","title":"col","text":"<p><pre><code>col(self: Self, id: Int) -&gt; Self\n</code></pre> Summary  </p> <p>Get the ith column of the matrix.  </p> <p>Args:  </p> <ul> <li>self</li> <li>id</li> </ul>"},{"location":"docs/core/ndarray/#rdot","title":"rdot","text":"<p><pre><code>rdot(self: Self, other: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Dot product of two matrix. Matrix A: M * N. Matrix B: N * L.  </p> <p>Args:  </p> <ul> <li>self</li> <li>other</li> </ul>"},{"location":"docs/core/ndarray/#size_1","title":"size","text":"<p><pre><code>size(self: Self) -&gt; Int\n</code></pre> Summary  </p> <p>Function to retreive size.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#num_elements","title":"num_elements","text":"<p><pre><code>num_elements(self: Self) -&gt; Int\n</code></pre> Summary  </p> <p>Function to retreive size (compatability).  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#shape","title":"shape","text":"<p><pre><code>shape(self: Self) -&gt; NDArrayShape[int32]\n</code></pre> Summary  </p> <p>Get the shape as an NDArray Shape.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#load_2","title":"load","text":"<p><pre><code>load[width: Int = 1](self: Self, index: Int) -&gt; SIMD[dtype, $0]\n</code></pre> Summary  </p> <p>Loads a SIMD element of size <code>width</code> at the given index <code>index</code>.  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> </ul> <p><pre><code>load[width: Int = 1](self: Self, *index: Int) -&gt; SIMD[dtype, $0]\n</code></pre> Summary  </p> <p>Loads a SIMD element of size <code>width</code> at given variadic indices argument.  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>*index</li> </ul>"},{"location":"docs/core/ndarray/#store_2","title":"store","text":"<p><pre><code>store[width: Int](inout self: Self, index: Int, val: SIMD[dtype, width])\n</code></pre> Summary  </p> <p>Stores the SIMD element of size <code>width</code> at index <code>index</code>.  </p> <p>Parameters:  </p> <ul> <li>width</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>index</li> <li>val</li> </ul> <p><pre><code>store[width: Int = 1](inout self: Self, *index: Int, *, val: SIMD[dtype, width])\n</code></pre> Summary  </p> <p>Stores the SIMD element of size <code>width</code> at the given variadic indices argument.  </p> <p>Parameters:  </p> <ul> <li>width Defualt: <code>1</code></li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>*index</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#all","title":"all","text":"<p><pre><code>all(self: Self) -&gt; Bool\n</code></pre> Summary  </p> <p>If all true return true.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#any","title":"any","text":"<p><pre><code>any(self: Self) -&gt; Bool\n</code></pre> Summary  </p> <p>True if any true.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#argmax","title":"argmax","text":"<p><pre><code>argmax(self: Self) -&gt; Int\n</code></pre> Summary  </p> <p>Get location in pointer of max value.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#argmin","title":"argmin","text":"<p><pre><code>argmin(self: Self) -&gt; Int\n</code></pre> Summary  </p> <p>Get location in pointer of min value.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#argsort","title":"argsort","text":"<p><pre><code>argsort(self: Self) -&gt; NDArray[index]\n</code></pre> Summary  </p> <p>Sort the NDArray and return the sorted indices.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#astype","title":"astype","text":"<p><pre><code>astype[type: DType](inout self: Self) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Convert type of array.  </p> <p>Parameters:  </p> <ul> <li>type</li> </ul> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#cumprod","title":"cumprod","text":"<p><pre><code>cumprod(self: Self) -&gt; SIMD[dtype, 1]\n</code></pre> Summary  </p> <p>Cumulative product of a array.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#cumsum","title":"cumsum","text":"<p><pre><code>cumsum(self: Self) -&gt; SIMD[dtype, 1]\n</code></pre> Summary  </p> <p>Cumulative Sum of a array.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#diagonal","title":"diagonal","text":"<p><pre><code>diagonal(self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#fill","title":"fill","text":"<p><pre><code>fill(inout self: Self, val: SIMD[dtype, 1]) -&gt; Self\n</code></pre> Summary  </p> <p>Fill all items of array with value.  </p> <p>Args:  </p> <ul> <li>self</li> <li>val</li> </ul>"},{"location":"docs/core/ndarray/#flatten","title":"flatten","text":"<p><pre><code>flatten(inout self: Self, inplace: Bool = 0) -&gt; Optional[NDArray[dtype]]\n</code></pre> Summary  </p> <p>Convert shape of array to one dimensional.  </p> <p>Args:  </p> <ul> <li>self</li> <li>inplace Default: 0</li> </ul>"},{"location":"docs/core/ndarray/#item","title":"item","text":"<p><pre><code>item(self: Self, *index: Int) -&gt; SIMD[dtype, 1]\n</code></pre> Summary  </p> <p>Return the scalar at the coordinates.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*index: The coordinates of the item.</li> </ul>"},{"location":"docs/core/ndarray/#max","title":"max","text":"<p><pre><code>max(self: Self, axis: Int = 0) -&gt; Self\n</code></pre> Summary  </p> <p>Max on axis.  </p> <p>Args:  </p> <ul> <li>self</li> <li>axis Default: 0</li> </ul>"},{"location":"docs/core/ndarray/#min","title":"min","text":"<p><pre><code>min(self: Self, axis: Int = 0) -&gt; Self\n</code></pre> Summary  </p> <p>Min on axis.  </p> <p>Args:  </p> <ul> <li>self</li> <li>axis Default: 0</li> </ul>"},{"location":"docs/core/ndarray/#mean","title":"mean","text":"<p><pre><code>mean(self: Self, axis: Int) -&gt; Self\n</code></pre> Summary  </p> <p>Mean of array elements over a given axis. Args:     array: NDArray.     axis: The axis along which the mean is performed. Returns:     An NDArray.  </p> <p>Args:  </p> <ul> <li>self</li> <li>axis</li> </ul> <p><pre><code>mean(self: Self) -&gt; SIMD[dtype, 1]\n</code></pre> Summary  </p> <p>Cumulative mean of a array.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#prod","title":"prod","text":"<p><pre><code>prod(self: Self, axis: Int) -&gt; Self\n</code></pre> Summary  </p> <p>Product of array elements over a given axis. Args:     array: NDArray.     axis: The axis along which the product is performed. Returns:     An NDArray.  </p> <p>Args:  </p> <ul> <li>self</li> <li>axis</li> </ul>"},{"location":"docs/core/ndarray/#sort","title":"sort","text":"<p><pre><code>sort(self: Self) -&gt; Self\n</code></pre> Summary  </p> <p>Sort the array using quickstort.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#sum","title":"sum","text":"<p><pre><code>sum(self: Self, axis: Int) -&gt; Self\n</code></pre> Summary  </p> <p>Sum of array elements over a given axis. Args:     axis: The axis along which the sum is performed. Returns:     An NDArray.  </p> <p>Args:  </p> <ul> <li>self</li> <li>axis</li> </ul>"},{"location":"docs/core/ndarray/#reshape","title":"reshape","text":"<p><pre><code>reshape(inout self: Self, *Shape: Int, *, order: String = \"C\")\n</code></pre> Summary  </p> <p>Reshapes the NDArray to given Shape.  </p> <p>Args:  </p> <ul> <li>self</li> <li>*Shape: Variadic list of shape.</li> <li>order: Order of the array - Row major <code>C</code> or Column major <code>F</code>. Default: \"C\"</li> </ul>"},{"location":"docs/core/ndarray/#unsafe_ptr","title":"unsafe_ptr","text":"<p><pre><code>unsafe_ptr(self: Self) -&gt; DTypePointer[dtype, 0]\n</code></pre> Summary  </p> <p>Retreive pointer without taking ownership.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray/#to_numpy","title":"to_numpy","text":"<p><pre><code>to_numpy(self: Self) -&gt; PythonObject\n</code></pre> Summary  </p> <p>Convert to a numpy array.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/core/ndarray_utils/","title":"ndarray_utils","text":""},{"location":"docs/core/ndarray_utils/#module-summary","title":"Module Summary","text":"<p>Implements N-DIMENSIONAL ARRAY UTILITY FUNCTIONS</p>"},{"location":"docs/core/ndarray_utils/#bool_to_numeric","title":"bool_to_numeric","text":"<p><pre><code>bool_to_numeric[dtype: DType](array: NDArray[bool]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Convert a boolean NDArray to a numeric NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The data type of the output NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>array: The boolean NDArray to convert.</li> </ul>"},{"location":"docs/core/ndarray_utils/#to_numpy","title":"to_numpy","text":"<p><pre><code>to_numpy[dtype: DType](array: NDArray[dtype]) -&gt; PythonObject\n</code></pre> Summary  </p> <p>Convert a NDArray to a numpy array.  </p> <p>Parameters:  </p> <ul> <li>dtype: The data type of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>array: The NDArray to convert.</li> </ul>"},{"location":"docs/core/random/","title":"random","text":""},{"location":"docs/core/random/#module-summary","title":"Module Summary","text":"<p>Random values array generation.</p>"},{"location":"docs/core/random/#rand","title":"rand","text":"<p><pre><code>rand[dtype: DType](*shape: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Generate a random NDArray of the given shape and dtype.  </p> <p>Parameters:  </p> <ul> <li>dtype: The data type of the NDArray elements.</li> </ul> <p>Args:  </p> <ul> <li>*shape: The shape of the NDArray.</li> </ul>"},{"location":"docs/core/sort/","title":"sort","text":""},{"location":"docs/core/sort/#module-summary","title":"Module Summary","text":"<p>Implements sort functions</p>"},{"location":"docs/core/sort/#bubble_sort","title":"bubble_sort","text":"<p><pre><code>bubble_sort[dtype: DType](ndarray: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Bubble sort the NDArray. Average complexity: O(n^2) comparisons, O(n^2) swaps. Worst-case complexity: O(n^2) comparisons, O(n^2) swaps. Worst-case space complexity: O(n).  </p> <p>Parameters:  </p> <ul> <li>dtype: The input element type.</li> </ul> <p>Args:  </p> <ul> <li>ndarray: An NDArray.</li> </ul>"},{"location":"docs/core/sort/#quick_sort_inplace","title":"quick_sort_inplace","text":"<p><pre><code>quick_sort_inplace[dtype: DType](inout ndarray: NDArray[dtype], left: Int, right: Int)\n</code></pre> Summary  </p> <p>Quick sort (in-place) the NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The input element type.</li> </ul> <p>Args:  </p> <ul> <li>ndarray: An NDArray.</li> <li>left: Left index of the partition.</li> <li>right: Right index of the partition.</li> </ul>"},{"location":"docs/core/sort/#quick_sort","title":"quick_sort","text":"<p><pre><code>quick_sort[dtype: DType](ndarray: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Quick sort the NDArray. Adopt in-place partition. Average complexity: O(nlogn). Worst-case complexity: O(n^2). Worst-case space complexity: O(n). Unstable.  </p> <p>Parameters:  </p> <ul> <li>dtype: The input element type.</li> </ul> <p>Args:  </p> <ul> <li>ndarray: An NDArray.</li> </ul>"},{"location":"docs/core/sort/#binary_sort","title":"binary_sort","text":"<p><pre><code>binary_sort[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Binary sorting of NDArray.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/core/sort/#argsort_inplace","title":"argsort_inplace","text":"<p><pre><code>argsort_inplace[dtype: DType](inout ndarray: NDArray[dtype], inout idx_array: NDArray[index], left: Int, right: Int)\n</code></pre> Summary  </p> <p>Conduct Argsort (in-place) based on the NDArray using quick sort.  </p> <p>Parameters:  </p> <ul> <li>dtype: The input element type.</li> </ul> <p>Args:  </p> <ul> <li>ndarray: An NDArray.</li> <li>idx_array: An NDArray of the indices.</li> <li>left: Left index of the partition.</li> <li>right: Right index of the partition.</li> </ul>"},{"location":"docs/core/sort/#argsort","title":"argsort","text":"<p><pre><code>argsort[dtype: DType](ndarray: NDArray[dtype]) -&gt; NDArray[index]\n</code></pre> Summary  </p> <p>Argsort of the NDArray using quick sort algorithm.  </p> <p>Parameters:  </p> <ul> <li>dtype: The input element type.</li> </ul> <p>Args:  </p> <ul> <li>ndarray: An NDArray.</li> </ul>"},{"location":"docs/core/utility_funcs/","title":"utility_funcs","text":""},{"location":"docs/core/utility_funcs/#module-summary","title":"Module Summary","text":"<p>Type related utility functions.</p>"},{"location":"docs/core/utility_funcs/#is_inttype","title":"is_inttype","text":"<p><pre><code>is_inttype[dtype: DType]() -&gt; Bool\n</code></pre> Summary  </p> <p>Check if the given dtype is an integer type at compile time.  </p> <p>Parameters:  </p> <ul> <li>dtype: DType.</li> </ul> <p><pre><code>is_inttype(dtype: DType) -&gt; Bool\n</code></pre> Summary  </p> <p>Check if the given dtype is an integer type at run time.  </p> <p>Args:  </p> <ul> <li>dtype: DType.</li> </ul>"},{"location":"docs/core/utility_funcs/#is_floattype","title":"is_floattype","text":"<p><pre><code>is_floattype[dtype: DType]() -&gt; Bool\n</code></pre> Summary  </p> <p>Check if the given dtype is a floating point type at compile time.  </p> <p>Parameters:  </p> <ul> <li>dtype: DType.</li> </ul> <p><pre><code>is_floattype(dtype: DType) -&gt; Bool\n</code></pre> Summary  </p> <p>Check if the given dtype is a floating point type at run time.  </p> <p>Args:  </p> <ul> <li>dtype: DType.</li> </ul>"},{"location":"docs/math/arithmetic/","title":"arithmetic","text":""},{"location":"docs/math/arithmetic/#module-summary","title":"Module Summary","text":"<p>Implements array arithmetic</p>"},{"location":"docs/math/arithmetic/#aliases","title":"Aliases","text":"<p><code>ln</code>: Natural Log equivelent to log</p>"},{"location":"docs/math/arithmetic/#add","title":"add","text":"<p><pre><code>add[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform addition on two arrays.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul> <p><pre><code>add[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform addition on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>scalar: A NDArray.</li> </ul> <p><pre><code>add[dtype: DType, backend: Backend = Vectorized](scalar: SIMD[dtype, 1], array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform addition on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>scalar: A NDArray.</li> <li>array: A NDArray.</li> </ul> <p><pre><code>add[dtype: DType, backend: Backend = Vectorized](owned *values: Variant[NDArray[dtype], SIMD[dtype, 1]]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform addition on a list of arrays and a scalars.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>*values: A list of arrays or Scalars to be added.</li> </ul>"},{"location":"docs/math/arithmetic/#sub","title":"sub","text":"<p><pre><code>sub[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform subtraction on two arrays.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul> <p><pre><code>sub[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform subtraction on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>scalar: A NDArray.</li> </ul> <p><pre><code>sub[dtype: DType, backend: Backend = Vectorized](scalar: SIMD[dtype, 1], array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform subtraction on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>scalar: A NDArray.</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#diff","title":"diff","text":"<p><pre><code>diff[in_dtype: DType, out_dtype: DType = $0](array: NDArray[in_dtype], n: Int) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Compute the n-th order difference of the input array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: Input data type.</li> <li>out_dtype: Output data type, defaults to float32. Defualt: <code>$0</code></li> </ul> <p>Args:  </p> <ul> <li>array: A array.</li> <li>n: The order of the difference.</li> </ul>"},{"location":"docs/math/arithmetic/#copysign","title":"copysign","text":"<p><pre><code>copysign[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Copy the sign of the first NDArray and apply it to the second NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#mod","title":"mod","text":"<p><pre><code>mod[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise modulo of array1 and array2.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul> <p><pre><code>mod[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform subtraction on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>scalar: A NDArray.</li> </ul> <p><pre><code>mod[dtype: DType, backend: Backend = Vectorized](scalar: SIMD[dtype, 1], array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform subtraction on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>scalar: A NDArray.</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#mul","title":"mul","text":"<p><pre><code>mul[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise product of array1 and array2.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul> <p><pre><code>mul[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform multiplication on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>scalar: A NDArray.</li> </ul> <p><pre><code>mul[dtype: DType, backend: Backend = Vectorized](scalar: SIMD[dtype, 1], array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform multiplication on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>scalar: A NDArray.</li> <li>array: A NDArray.</li> </ul> <p><pre><code>mul[dtype: DType, backend: Backend = Vectorized](owned *values: Variant[NDArray[dtype], SIMD[dtype, 1]]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform multiplication on a list of arrays an arrays and a scalars.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>*values: A list of arrays or Scalars to be added.</li> </ul>"},{"location":"docs/math/arithmetic/#div","title":"div","text":"<p><pre><code>div[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise quotent of array1 and array2.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul> <p><pre><code>div[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform true division on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>scalar: A NDArray.</li> </ul> <p><pre><code>div[dtype: DType, backend: Backend = Vectorized](scalar: SIMD[dtype, 1], array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform true division on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>scalar: A NDArray.</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#floor_div","title":"floor_div","text":"<p><pre><code>floor_div[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise quotent of array1 and array2.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul> <p><pre><code>floor_div[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform true division on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>scalar: A NDArray.</li> </ul> <p><pre><code>floor_div[dtype: DType, backend: Backend = Vectorized](scalar: SIMD[dtype, 1], array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Perform true division on between an array and a scalar.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>scalar: A NDArray.</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#fma","title":"fma","text":"<p><pre><code>fma[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>fma[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/arithmetic/#remainder","title":"remainder","text":"<p><pre><code>remainder[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise remainders of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#cbrt","title":"cbrt","text":"<p><pre><code>cbrt[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise cuberoot of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#rsqrt","title":"rsqrt","text":"<p><pre><code>rsqrt[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise reciprocal squareroot of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#sqrt","title":"sqrt","text":"<p><pre><code>sqrt[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise squareroot of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#exp2","title":"exp2","text":"<p><pre><code>exp2[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Calculate elementwise two to the power of NDArray[i].  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#exp","title":"exp","text":"<p><pre><code>exp[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Calculate elementwise euler's constant(e) to the power of NDArray[i].  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#expm1","title":"expm1","text":"<p><pre><code>expm1[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Calculate elementwise euler's constant(e) to the power of NDArray[i] minus1.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#scalb","title":"scalb","text":"<p><pre><code>scalb[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Calculate the scalb of array1 and array2.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#log","title":"log","text":"<p><pre><code>log[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise natural logarithm of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#log2","title":"log2","text":"<p><pre><code>log2[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise logarithm base two of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#log10","title":"log10","text":"<p><pre><code>log10[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise logarithm base ten of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#log1p","title":"log1p","text":"<p><pre><code>log1p[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise natural logarithm of 1 plus NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#tabs","title":"tabs","text":"<p><pre><code>tabs[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise absolute value of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#tfloor","title":"tfloor","text":"<p><pre><code>tfloor[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise round down to nearest whole number of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#tceil","title":"tceil","text":"<p><pre><code>tceil[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise round up to nearest whole number of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#ttrunc","title":"ttrunc","text":"<p><pre><code>ttrunc[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise remove decimal value from float whole number of NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#tround","title":"tround","text":"<p><pre><code>tround[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise round NDArray to whole number.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/arithmetic/#roundeven","title":"roundeven","text":"<p><pre><code>roundeven[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Performs elementwise banker's rounding on the elements of a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input and output array.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: Array to perform rounding on.</li> </ul>"},{"location":"docs/math/arithmetic/#nextafter","title":"nextafter","text":"<p><pre><code>nextafter[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Computes the nextafter of the inputs.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input and output array. Constraints: must be a floating-point type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array1: The first input argument.</li> <li>array2: The second input argument.</li> </ul>"},{"location":"docs/math/arithmetic/#invert","title":"invert","text":"<p><pre><code>invert[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Elementwise invert of an array.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized</code>. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/check/","title":"check","text":""},{"location":"docs/math/check/#module-summary","title":"Module Summary","text":"<p>Implements Checking routines: currently not SIMD due to bool bit packing issue</p>"},{"location":"docs/math/check/#isinf","title":"isinf","text":"<p><pre><code>isinf[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Checks if each element of the input array is infinite.  </p> <p>Parameters:  </p> <ul> <li>dtype: DType - Data type of the input array.</li> <li>backend: _mf.Backend - Backend to use for the operation. Defaults to _mf.Vectorized. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: NDArray[dtype] - Input array to check.</li> </ul>"},{"location":"docs/math/check/#isfinite","title":"isfinite","text":"<p><pre><code>isfinite[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Checks if each element of the input array is finite.  </p> <p>Parameters:  </p> <ul> <li>dtype: DType - Data type of the input array.</li> <li>backend: _mf.Backend - Backend to use for the operation. Defaults to _mf.Vectorized. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: NDArray[dtype] - Input array to check.</li> </ul>"},{"location":"docs/math/check/#isnan","title":"isnan","text":"<p><pre><code>isnan[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Checks if each element of the input array is NaN.  </p> <p>Parameters:  </p> <ul> <li>dtype: DType - Data type of the input array.</li> <li>backend: _mf.Backend - Backend to use for the operation. Defaults to _mf.Vectorized. Defualt: <code>Vectorized</code></li> </ul> <p>Args:  </p> <ul> <li>array: NDArray[dtype] - Input array to check.</li> </ul>"},{"location":"docs/math/check/#any","title":"any","text":"<p><pre><code>any(array: NDArray[bool]) -&gt; SIMD[bool, 1]\n</code></pre> Summary  </p> <p>If any True.  </p> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/check/#allt","title":"allt","text":"<p><pre><code>allt(array: NDArray[bool]) -&gt; SIMD[bool, 1]\n</code></pre> Summary  </p> <p>If all True.  </p> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/comparison/","title":"comparison","text":""},{"location":"docs/math/comparison/#module-summary","title":"Module Summary","text":"<p>Implements comparison math currently not using backend due to bool bitpacking issue</p>"},{"location":"docs/math/comparison/#greater","title":"greater","text":"<p><pre><code>greater[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Performs elementwise check of whether values in x are greater than values in y.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input NDArray.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: First NDArray to compare.</li> <li>array2: Second NDArray to compare.</li> </ul>"},{"location":"docs/math/comparison/#greater_equal","title":"greater_equal","text":"<p><pre><code>greater_equal[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Performs elementwise check of whether values in x are greater than or equal to values in y.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input NDArray.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: First NDArray to compare.</li> <li>array2: Second NDArray to compare.</li> </ul>"},{"location":"docs/math/comparison/#less","title":"less","text":"<p><pre><code>less[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Performs elementwise check of whether values in x are to values in y.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input NDArray.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: First NDArray to compare.</li> <li>array2: Second NDArray to compare.</li> </ul>"},{"location":"docs/math/comparison/#less_equal","title":"less_equal","text":"<p><pre><code>less_equal[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Performs elementwise check of whether values in x are less than or equal to values in y.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input NDArray.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: First NDArray to compare.</li> <li>array2: Second NDArray to compare.</li> </ul>"},{"location":"docs/math/comparison/#equal","title":"equal","text":"<p><pre><code>equal[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Performs elementwise check of whether values in x are equal to values in y.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input NDArray.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: First NDArray to compare.</li> <li>array2: Second NDArray to compare.</li> </ul>"},{"location":"docs/math/comparison/#not_equal","title":"not_equal","text":"<p><pre><code>not_equal[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Performs elementwise check of whether values in x are not equal to values in y.  </p> <p>Parameters:  </p> <ul> <li>dtype: The dtype of the input NDArray.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: First NDArray to compare.</li> <li>array2: Second NDArray to compare.</li> </ul>"},{"location":"docs/math/interpolate/","title":"interpolate","text":""},{"location":"docs/math/interpolate/#module-summary","title":"Module Summary","text":""},{"location":"docs/math/math_funcs/","title":"math_funcs","text":""},{"location":"docs/math/math_funcs/#module-summary","title":"Module Summary","text":"<p>Implements backend functions for mathematics</p>"},{"location":"docs/math/math_funcs/#vectorized","title":"Vectorized","text":""},{"location":"docs/math/math_funcs/#vectorized-summary","title":"Vectorized Summary","text":"<p>Vectorized Backend Struct. Parameters     unroll_factor: factor by which loops are unrolled.  </p>"},{"location":"docs/math/math_funcs/#parent-traits","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Backend</li> </ul>"},{"location":"docs/math/math_funcs/#functions","title":"Functions","text":""},{"location":"docs/math/math_funcs/#init","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_fma","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_in_one_array_out","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_2_array_in_one_array_out","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_1_scalar_in_one_array_out","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_compare_2_arrays","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>array2</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_is","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_simd_int","title":"math_func_simd_int","text":"<p><pre><code>math_func_simd_int[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], Int) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], intval: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> <li>intval</li> </ul>"},{"location":"docs/math/math_funcs/#vectorizedunroll","title":"VectorizedUnroll","text":""},{"location":"docs/math/math_funcs/#vectorizedunroll-summary","title":"VectorizedUnroll Summary","text":"<p>Vectorized Backend Struct. Parameters     unroll_factor: factor by which loops are unrolled.  </p>"},{"location":"docs/math/math_funcs/#parent-traits_1","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Backend</li> </ul>"},{"location":"docs/math/math_funcs/#functions_1","title":"Functions","text":""},{"location":"docs/math/math_funcs/#init_1","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_fma_1","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_in_one_array_out_1","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_2_array_in_one_array_out_1","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_1_scalar_in_one_array_out_1","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_compare_2_arrays_1","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>array2</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_is_1","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_simd_int_1","title":"math_func_simd_int","text":"<p><pre><code>math_func_simd_int[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], Int) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], intval: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> <li>intval</li> </ul>"},{"location":"docs/math/math_funcs/#parallelized","title":"Parallelized","text":""},{"location":"docs/math/math_funcs/#parallelized-summary","title":"Parallelized Summary","text":"<p>Parrallelized Backend Struct.  </p>"},{"location":"docs/math/math_funcs/#parent-traits_2","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Backend</li> </ul>"},{"location":"docs/math/math_funcs/#functions_2","title":"Functions","text":""},{"location":"docs/math/math_funcs/#init_2","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_fma_2","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_in_one_array_out_2","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_2_array_in_one_array_out_2","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_1_scalar_in_one_array_out_2","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_compare_2_arrays_2","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>array2</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_is_2","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_simd_int_2","title":"math_func_simd_int","text":"<p><pre><code>math_func_simd_int[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], Int) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], intval: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> <li>intval</li> </ul>"},{"location":"docs/math/math_funcs/#vectorizedparallelized","title":"VectorizedParallelized","text":""},{"location":"docs/math/math_funcs/#vectorizedparallelized-summary","title":"VectorizedParallelized Summary","text":"<p>Vectorized and Parrallelized Backend Struct.  </p>"},{"location":"docs/math/math_funcs/#parent-traits_3","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Backend</li> </ul>"},{"location":"docs/math/math_funcs/#functions_3","title":"Functions","text":""},{"location":"docs/math/math_funcs/#init_3","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_fma_3","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_in_one_array_out_3","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_2_array_in_one_array_out_3","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_1_scalar_in_one_array_out_3","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_compare_2_arrays_3","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>array2</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_is_3","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_simd_int_3","title":"math_func_simd_int","text":"<p><pre><code>math_func_simd_int[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], Int) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], intval: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> <li>intval</li> </ul>"},{"location":"docs/math/math_funcs/#vectorizedparallelizednworkers","title":"VectorizedParallelizedNWorkers","text":""},{"location":"docs/math/math_funcs/#vectorizedparallelizednworkers-summary","title":"VectorizedParallelizedNWorkers Summary","text":"<p>Vectorized and Parrallelized Backend Struct with manual setting of number of workers.  </p>"},{"location":"docs/math/math_funcs/#parent-traits_4","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Backend</li> </ul>"},{"location":"docs/math/math_funcs/#functions_4","title":"Functions","text":""},{"location":"docs/math/math_funcs/#init_4","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_fma_4","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_in_one_array_out_4","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_2_array_in_one_array_out_4","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_1_scalar_in_one_array_out_4","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_compare_2_arrays_4","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>array2</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_is_4","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_simd_int_4","title":"math_func_simd_int","text":"<p><pre><code>math_func_simd_int[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], Int) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], intval: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> <li>intval</li> </ul>"},{"location":"docs/math/math_funcs/#naive","title":"Naive","text":""},{"location":"docs/math/math_funcs/#naive-summary","title":"Naive Summary","text":"<p>Naive Backend Struct.  </p>"},{"location":"docs/math/math_funcs/#parent-traits_5","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Backend</li> </ul>"},{"location":"docs/math/math_funcs/#functions_5","title":"Functions","text":""},{"location":"docs/math/math_funcs/#init_5","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_fma_5","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_in_one_array_out_5","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_2_array_in_one_array_out_5","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_1_scalar_in_one_array_out_5","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_compare_2_arrays_5","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>array2</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_is_5","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_simd_int_5","title":"math_func_simd_int","text":"<p><pre><code>math_func_simd_int[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], Int) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], intval: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> <li>intval</li> </ul>"},{"location":"docs/math/math_funcs/#vectorizedverbose","title":"VectorizedVerbose","text":""},{"location":"docs/math/math_funcs/#vectorizedverbose-summary","title":"VectorizedVerbose Summary","text":"<p>Vectorized Backend Struct.  </p>"},{"location":"docs/math/math_funcs/#parent-traits_6","title":"Parent Traits","text":"<ul> <li>AnyType</li> <li>Backend</li> </ul>"},{"location":"docs/math/math_funcs/#functions_6","title":"Functions","text":""},{"location":"docs/math/math_funcs/#init_6","title":"init","text":"<p><pre><code>__init__(inout self: Self)\n</code></pre> Summary  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_fma_6","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: Self, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_in_one_array_out_6","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_2_array_in_one_array_out_6","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_1_array_1_scalar_in_one_array_out_6","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: Self, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_compare_2_arrays_6","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>array2</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_is_6","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: Self, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"docs/math/math_funcs/#math_func_simd_int_6","title":"math_func_simd_int","text":"<p><pre><code>math_func_simd_int[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], Int) -&gt; SIMD[$0, $1]](self: Self, array1: NDArray[dtype], intval: Int) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1</li> <li>intval</li> </ul>"},{"location":"docs/math/math_funcs/#bool_simd_store","title":"bool_simd_store","text":"<p><pre><code>bool_simd_store[width: Int](ptr: DTypePointer[bool, 0], start: Int, val: SIMD[bool, width])\n</code></pre> Summary  </p> <p>Work around function for storing bools from a simd into a DTypePointer.  </p> <p>Parameters:  </p> <ul> <li>width: Number of items to be retrieved.</li> </ul> <p>Args:  </p> <ul> <li>ptr: Pointer to be retreived from.</li> <li>start: Start position in pointer.</li> <li>val: Value to store at locations.</li> </ul>"},{"location":"docs/math/trig/","title":"trig","text":""},{"location":"docs/math/trig/#module-summary","title":"Module Summary","text":"<p>Implements Trigonometry functions for arrays.</p>"},{"location":"docs/math/trig/#acos","title":"acos","text":"<p><pre><code>acos[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply acos also known as inverse cosine .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array.</li> </ul>"},{"location":"docs/math/trig/#asin","title":"asin","text":"<p><pre><code>asin[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply asin also known as inverse sine .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array.</li> </ul>"},{"location":"docs/math/trig/#atan","title":"atan","text":"<p><pre><code>atan[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply atan also known as inverse tangent .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array.</li> </ul>"},{"location":"docs/math/trig/#atan2","title":"atan2","text":"<p><pre><code>atan2[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply atan2 also known as inverse tangent. atan2 wikipedia.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: An Array.</li> <li>array2: An Array.</li> </ul>"},{"location":"docs/math/trig/#cos","title":"cos","text":"<p><pre><code>cos[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply cos also known as cosine.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array assumed to be in radian.</li> </ul>"},{"location":"docs/math/trig/#sin","title":"sin","text":"<p><pre><code>sin[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply sin also known as sine .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array assumed to be in radian.</li> </ul>"},{"location":"docs/math/trig/#tan","title":"tan","text":"<p><pre><code>tan[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply tan also known as tangent .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array assumed to be in radian.</li> </ul>"},{"location":"docs/math/trig/#hypot","title":"hypot","text":"<p><pre><code>hypot[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply hypot also known as hypotenuse which finds the longest section of a right triangle given the other two sides.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: An Array.</li> <li>array2: An Array.</li> </ul>"},{"location":"docs/math/trig/#hypot_fma","title":"hypot_fma","text":"<p><pre><code>hypot_fma[dtype: DType, backend: Backend = Vectorized](array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply hypot also known as hypotenuse which finds the longest section of a right triangle given the other two sides.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array1: An Array.</li> <li>array2: An Array.</li> </ul>"},{"location":"docs/math/trig/#acosh","title":"acosh","text":"<p><pre><code>acosh[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply acosh also known as inverse hyperbolic cosine .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array.</li> </ul>"},{"location":"docs/math/trig/#asinh","title":"asinh","text":"<p><pre><code>asinh[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply asinh also known as inverse hyperbolic sine .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array.</li> </ul>"},{"location":"docs/math/trig/#atanh","title":"atanh","text":"<p><pre><code>atanh[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply atanh also known as inverse hyperbolic tangent .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array.</li> </ul>"},{"location":"docs/math/trig/#cosh","title":"cosh","text":"<p><pre><code>cosh[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply cosh also known as hyperbolic cosine .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array assumed to be in radian.</li> </ul>"},{"location":"docs/math/trig/#sinh","title":"sinh","text":"<p><pre><code>sinh[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply sin also known as hyperbolic sine .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array assumed to be in radian.</li> </ul>"},{"location":"docs/math/trig/#tanh","title":"tanh","text":"<p><pre><code>tanh[dtype: DType, backend: Backend = Vectorized](array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply tan also known as hyperbolic tangent .  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>backend: Sets utility function origin, defualts to <code>Vectorized. Defualt:</code>Vectorized`</li> </ul> <p>Args:  </p> <ul> <li>array: An Array assumed to be in radian.</li> </ul>"},{"location":"docs/math/calculus/differentiation/","title":"differentiation","text":""},{"location":"docs/math/calculus/differentiation/#module-summary","title":"Module Summary","text":""},{"location":"docs/math/calculus/differentiation/#gradient","title":"gradient","text":"<p><pre><code>gradient[in_dtype: DType, out_dtype: DType = float32](x: NDArray[in_dtype], spacing: SIMD[in_dtype, 1]) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Compute the integral of y over x using the trapezoidal rule.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: Input data type.</li> <li>out_dtype: Output data type, defaults to float32. Defualt: <code>float32</code></li> </ul> <p>Args:  </p> <ul> <li>x: An array.</li> <li>spacing: An array of the same shape as x containing the spacing between adjacent elements.</li> </ul>"},{"location":"docs/math/calculus/integral/","title":"integral","text":""},{"location":"docs/math/calculus/integral/#module-summary","title":"Module Summary","text":""},{"location":"docs/math/calculus/integral/#trapz","title":"trapz","text":"<p><pre><code>trapz[in_dtype: DType, out_dtype: DType = float32](y: NDArray[in_dtype], x: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Compute the integral of y over x using the trapezoidal rule.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: Input data type.</li> <li>out_dtype: Output data type, defaults to float32. Defualt: <code>float32</code></li> </ul> <p>Args:  </p> <ul> <li>y: An array.</li> <li>x: An array.</li> </ul>"},{"location":"docs/math/linalg/linalg/","title":"linalg","text":""},{"location":"docs/math/linalg/linalg/#module-summary","title":"Module Summary","text":"<p>Linear Algebra misc. functions</p>"},{"location":"docs/math/linalg/linalg/#cross","title":"cross","text":"<p><pre><code>cross[in_dtype: DType, out_dtype: DType = float32](array1: NDArray[in_dtype], array2: NDArray[in_dtype]) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Compute the cross product of two arrays.  </p> <p>Parameters:  </p> <ul> <li>in_dtype</li> <li>out_dtype Defualt: <code>float32</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A array.</li> <li>array2: A array.</li> </ul>"},{"location":"docs/math/linalg/matmul/","title":"matmul","text":""},{"location":"docs/math/linalg/matmul/#module-summary","title":"Module Summary","text":"<p>Matrix multiplication functions for NDArrays</p>"},{"location":"docs/math/linalg/matmul/#tile","title":"tile","text":"<p><pre><code>tile[tiled_fn: fn[Int, Int](Int, Int) capturing -&gt; None, tile_x: Int, tile_y: Int](end_x: Int, end_y: Int)\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>tiled_fn</li> <li>tile_x</li> <li>tile_y</li> </ul> <p>Args:  </p> <ul> <li>end_x</li> <li>end_y</li> </ul>"},{"location":"docs/math/linalg/matmul/#matmul_tiled_unrolled_parallelized","title":"matmul_tiled_unrolled_parallelized","text":"<p><pre><code>matmul_tiled_unrolled_parallelized[dtype: DType](A: NDArray[dtype], B: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Matrix multiplication vectorized, tiled, unrolled, and parallelized.  </p> <p>Parameters:  </p> <ul> <li>dtype</li> </ul> <p>Args:  </p> <ul> <li>A</li> <li>B</li> </ul>"},{"location":"docs/math/linalg/matmul/#matmul_parallelized","title":"matmul_parallelized","text":"<p><pre><code>matmul_parallelized[dtype: DType](A: NDArray[dtype], B: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Matrix multiplication Vectorized and parallelized.  </p> <p>Parameters:  </p> <ul> <li>dtype</li> </ul> <p>Args:  </p> <ul> <li>A</li> <li>B</li> </ul>"},{"location":"docs/math/linalg/matmul/#matmul_naive","title":"matmul_naive","text":"<p><pre><code>matmul_naive[dtype: DType](A: NDArray[dtype], B: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Matrix multiplication with three nested loops.  </p> <p>Parameters:  </p> <ul> <li>dtype</li> </ul> <p>Args:  </p> <ul> <li>A</li> <li>B</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/","title":"cumulative_reduce","text":""},{"location":"docs/math/statistics/cumulative_reduce/#module-summary","title":"Module Summary","text":"<p>Cumulative reduction statistics functions for NDArrays</p>"},{"location":"docs/math/statistics/cumulative_reduce/#cumsum","title":"cumsum","text":"<p><pre><code>cumsum[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Sum of all items of an array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: An NDArray.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#cumprod","title":"cumprod","text":"<p><pre><code>cumprod[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Product of all items in an array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: An NDArray.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#cummean","title":"cummean","text":"<p><pre><code>cummean[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Arithmatic mean of all items of an array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: An NDArray.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#mode","title":"mode","text":"<p><pre><code>mode[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Mode of all items of an array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: An NDArray.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#median","title":"median","text":"<p><pre><code>median[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Median value of all items of an array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: An NDArray.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#maxt","title":"maxT","text":"<p><pre><code>maxT[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Maximum value of a array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#mint","title":"minT","text":"<p><pre><code>minT[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Minimum value of a array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#cumpvariance","title":"cumpvariance","text":"<p><pre><code>cumpvariance[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype], mu: Optional[SIMD[in_dtype, 1]] = #kgen.none) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Population variance of a array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type.. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>mu: The mean of the array, if provided. Default: #kgen.none</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#cumvariance","title":"cumvariance","text":"<p><pre><code>cumvariance[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype], mu: Optional[SIMD[in_dtype, 1]] = #kgen.none) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Variance of a array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>mu: The mean of the array, if provided. Default: #kgen.none</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#cumpstdev","title":"cumpstdev","text":"<p><pre><code>cumpstdev[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype], mu: Optional[SIMD[in_dtype, 1]] = #kgen.none) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Population standard deviation of a array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>mu: The mean of the array, if provided. Default: #kgen.none</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#cumstdev","title":"cumstdev","text":"<p><pre><code>cumstdev[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype], mu: Optional[SIMD[in_dtype, 1]] = #kgen.none) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Standard deviation of a array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A NDArray.</li> <li>mu: The mean of the array, if provided. Default: #kgen.none</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#amin","title":"amin","text":"<p><pre><code>amin[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Minimum value of an array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: An array.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#amax","title":"amax","text":"<p><pre><code>amax[in_dtype: DType, out_dtype: DType = float64](array: NDArray[in_dtype]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Maximum value of a array.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array: A array.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#mimimum","title":"mimimum","text":"<p><pre><code>mimimum[in_dtype: DType, out_dtype: DType = float64](s1: SIMD[in_dtype, 1], s2: SIMD[in_dtype, 1]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Minimum value of two SIMD values.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>s1: A SIMD Value.</li> <li>s2: A SIMD Value.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#maximum","title":"maximum","text":"<p><pre><code>maximum[in_dtype: DType, out_dtype: DType = float64](s1: SIMD[in_dtype, 1], s2: SIMD[in_dtype, 1]) -&gt; SIMD[$1, 1]\n</code></pre> Summary  </p> <p>Maximum value of two SIMD values.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>s1: A SIMD Value.</li> <li>s2: A SIMD Value.</li> </ul> <p><pre><code>maximum[in_dtype: DType, out_dtype: DType = float64](array1: NDArray[in_dtype], array2: NDArray[in_dtype]) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Element wise maximum of two arrays.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array1: A array.</li> <li>array2: A array.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#minimum","title":"minimum","text":"<p><pre><code>minimum[in_dtype: DType, out_dtype: DType = float64](array1: NDArray[in_dtype], array2: NDArray[in_dtype]) -&gt; NDArray[$1]\n</code></pre> Summary  </p> <p>Element wise minimum of two arrays.  </p> <p>Parameters:  </p> <ul> <li>in_dtype: The input element type.</li> <li>out_dtype: The output element type. Defualt: <code>float64</code></li> </ul> <p>Args:  </p> <ul> <li>array1: An array.</li> <li>array2: An array.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#argmax","title":"argmax","text":"<p><pre><code>argmax[dtype: DType](array: NDArray[dtype]) -&gt; Int\n</code></pre> Summary  </p> <p>Argmax of a array.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>array: A array.</li> </ul>"},{"location":"docs/math/statistics/cumulative_reduce/#argmin","title":"argmin","text":"<p><pre><code>argmin[dtype: DType](array: NDArray[dtype]) -&gt; Int\n</code></pre> Summary  </p> <p>Argmin of a array. Parameters:     dtype: The element type.  </p> <p>Parameters:  </p> <ul> <li>dtype</li> </ul> <p>Args:  </p> <ul> <li>array: A array.</li> </ul>"},{"location":"docs/math/statistics/stats/","title":"stats","text":""},{"location":"docs/math/statistics/stats/#module-summary","title":"Module Summary","text":"<p>Statistics functions for NDArray</p>"},{"location":"docs/math/statistics/stats/#sum","title":"sum","text":"<p><pre><code>sum(array: NDArray[dtype], axis: Int = 0) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Sum of array elements over a given axis.  </p> <p>Args:  </p> <ul> <li>array: NDArray.</li> <li>axis: The axis along which the sum is performed. Default: 0</li> </ul>"},{"location":"docs/math/statistics/stats/#sumall","title":"sumall","text":"<p><pre><code>sumall(array: NDArray[dtype]) -&gt; SIMD[$0, 1]\n</code></pre> Summary  </p> <p>Sum of all items in the array.  </p> <p>Args:  </p> <ul> <li>array: NDArray.</li> </ul>"},{"location":"docs/math/statistics/stats/#prod","title":"prod","text":"<p><pre><code>prod(array: NDArray[dtype], axis: Int = 0) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Product of array elements over a given axis.  </p> <p>Args:  </p> <ul> <li>array: NDArray.</li> <li>axis: The axis along which the product is performed. Default: 0</li> </ul>"},{"location":"docs/math/statistics/stats/#prodall","title":"prodall","text":"<p><pre><code>prodall(array: NDArray[dtype]) -&gt; SIMD[$0, 1]\n</code></pre> Summary  </p> <p>Product of all items in the array.  </p> <p>Args:  </p> <ul> <li>array: NDArray.</li> </ul>"},{"location":"docs/math/statistics/stats/#mean","title":"mean","text":"<p><pre><code>mean(array: NDArray[dtype], axis: Int = 0) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Mean of array elements over a given axis. Args:     array: NDArray.     axis: The axis along which the mean is performed. Returns:     An NDArray.  </p> <p>Args:  </p> <ul> <li>array</li> <li>axis Default: 0</li> </ul>"},{"location":"docs/math/statistics/stats/#meanall","title":"meanall","text":"<p><pre><code>meanall(array: NDArray[dtype]) -&gt; SIMD[float64, 1]\n</code></pre> Summary  </p> <p>Mean of all items in the array.  </p> <p>Args:  </p> <ul> <li>array: NDArray.</li> </ul>"},{"location":"docs/math/statistics/stats/#max","title":"max","text":"<p><pre><code>max[dtype: DType](array: NDArray[dtype], axis: Int = 0) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Maximums of array elements over a given axis.  </p> <p>Parameters:  </p> <ul> <li>dtype</li> </ul> <p>Args:  </p> <ul> <li>array: NDArray.</li> <li>axis: The axis along which the sum is performed. Default: 0</li> </ul>"},{"location":"docs/math/statistics/stats/#min","title":"min","text":"<p><pre><code>min[dtype: DType](array: NDArray[dtype], axis: Int = 0) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Minumums of array elements over a given axis.  </p> <p>Parameters:  </p> <ul> <li>dtype</li> </ul> <p>Args:  </p> <ul> <li>array: NDArray.</li> <li>axis: The axis along which the sum is performed. Default: 0</li> </ul>"},{"location":"docs/traits/NDArrayTraits/","title":"NDArrayTraits","text":""},{"location":"docs/traits/NDArrayTraits/#module-summary","title":"Module Summary","text":""},{"location":"docs/traits/backend/","title":"backend","text":""},{"location":"docs/traits/backend/#module-summary","title":"Module Summary","text":""},{"location":"docs/traits/backend/#backend_1","title":"Backend","text":""},{"location":"docs/traits/backend/#backend-summary","title":"Backend Summary","text":"<p>A trait that defines backends for calculations in the rest of the library.  </p>"},{"location":"docs/traits/backend/#parent-traits","title":"Parent Traits","text":"<ul> <li>AnyType</li> </ul>"},{"location":"docs/traits/backend/#functions","title":"Functions","text":""},{"location":"docs/traits/backend/#init","title":"init","text":"<p><pre><code>__init__(inout self: T, /)\n</code></pre> Summary  </p> <p>Initialize the backend.  </p> <p>Args:  </p> <ul> <li>self</li> </ul>"},{"location":"docs/traits/backend/#math_func_fma","title":"math_func_fma","text":"<p><pre><code>math_func_fma[dtype: DType](self: T, array1: NDArray[dtype], array2: NDArray[dtype], array3: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>array3: A NDArray.</li> </ul> <p><pre><code>math_func_fma[dtype: DType](self: T, array1: NDArray[dtype], array2: NDArray[dtype], simd: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD level fuse multipy add function of three variables and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> <li>simd: A SIMD[dtype,1] value to be added.</li> </ul>"},{"location":"docs/traits/backend/#math_func_1_array_in_one_array_out","title":"math_func_1_array_in_one_array_out","text":"<p><pre><code>math_func_1_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: T, array: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of one variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> </ul>"},{"location":"docs/traits/backend/#math_func_2_array_in_one_array_out","title":"math_func_2_array_in_one_array_out","text":"<p><pre><code>math_func_2_array_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: T, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/traits/backend/#math_func_1_array_1_scalar_in_one_array_out","title":"math_func_1_array_1_scalar_in_one_array_out","text":"<p><pre><code>math_func_1_array_1_scalar_in_one_array_out[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[$0, $1]](self: T, array: NDArray[dtype], scalar: SIMD[dtype, 1]) -&gt; NDArray[$0]\n</code></pre> Summary  </p> <p>Apply a SIMD function of two variable and one return to a NDArray.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array: A NDArray.</li> <li>scalar: A Scalars.</li> </ul>"},{"location":"docs/traits/backend/#math_func_compare_2_arrays","title":"math_func_compare_2_arrays","text":"<p><pre><code>math_func_compare_2_arrays[dtype: DType, func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: T, array1: NDArray[dtype], array2: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Apply a SIMD comparison functions to two NDArrays.  </p> <p>Parameters:  </p> <ul> <li>dtype: The element type.</li> <li>func: The SIMD function to to apply.</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array1: A NDArray.</li> <li>array2: A NDArray.</li> </ul>"},{"location":"docs/traits/backend/#math_func_is","title":"math_func_is","text":"<p><pre><code>math_func_is[dtype: DType, func: fn[DType, Int](SIMD[$0, $1]) -&gt; SIMD[bool, $1]](self: T, array: NDArray[dtype]) -&gt; NDArray[bool]\n</code></pre> Summary  </p> <p>Parameters:  </p> <ul> <li>dtype</li> <li>func</li> </ul> <p>Args:  </p> <ul> <li>self</li> <li>array</li> </ul>"},{"location":"getting_started/install/","title":"Installation","text":"<p>Mojo does not have a package manager yet so there are two options to install NuMojo.</p>"},{"location":"getting_started/install/#git-clone","title":"Git Clone","text":"<p>Use this if you are planning to contribute or if you want to see how it works under the hood.</p> <p>If you are using VScode just  copy this url: https://github.com/Mojo-Numerics-and-Algorithms-group/NuMojo.git and paste.</p> <p>If you use the command line run the following.</p> <pre><code>git clone https://github.com/Mojo-Numerics-and-Algorithms-group/NuMojo.git\n</code></pre>"},{"location":"getting_started/install/#mojo-package-in-the-release","title":"Mojo Package in the Release","text":"<p>Releases contains the major versions of Numojo, just download the mojopkg file and move it to your working directory.</p>"}]}